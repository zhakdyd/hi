<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Insert title here</title>
    <style>
        table { border-spacing: 0; border: 1px solid #000000; }
        tr,td,th { border: 1px solid #000000; margin:0; padding:0; }
    </style>
    <script>
    </script>
</head>
<body>
    <pre>

apply: The apply() method calls a function with a given this value, and arguments provided as an array        
call : The call() method calls a function with a given this value and arguments provided individually.

apply() 메서드는 함수를 호출하는 메서드다. 주어진 this 값과 배열 (또는 유사 배열 객체) 로 제공되는 arguments 로 함수를 호출합니다.
call() 메소드는 함수를 호출하는 메서드다. 주어진 this 값 및 각각 전달된 인수와 함께 함수를 호출합니다.

참고: 이 함수의 구문은 거의 call() 구문과 유사합니다. 
근본적인 차이점은  call() 은 함수에 전달될 인수 리스트를 받는데 비해, 
apply() 는 인수들의 단일 배열을 받는다는 점입니다.




call 메소드는 다른 객체 대신 메소드를 호출하는데 사용됩니다. 
이 메서드를 사용하여 함수의 this 객체를 원래 컨텍스트에서 thisObj로 지정된 새객체로 변경할 수 있습니다.


call과 apply의 공통점은 함수를 호출하는 메서드이지만, 







function sum(num1, num2) {
    return num1 + num2;
}
 
console.log(sum(1, 2));
console.log(sum.call(this, 1, 2));
sum(1, 2), sum.call(this, 1, 2) 두 함수는 같은 결과 값을 보이고 있습니다. 
그렇다면 sum.call(this, 1, 2)를 사용하는 이유는 무엇일까요?
--> call 함수를 사용한다면, call에 인자로 this를 넘겨줌으로, 
    this에 값에 따라 함수 안에서 출력되는 값이 달라지는 것을 확인 할 수 있습니다.


type = "zero";
var type1 = { type: "one" };
var type2 = { type: "two" };
 
function getType() {
    console.log(this.type);
}
 
getType();
getType.call(this);
getType.call(type1);
getType.call(type2);


출처: https://beomy.tistory.com/4 [beomy]

    </pre>

    <table>
        <colgroup>
            <col style="width:100px;"/>
            <col style="width:400px;"/>
            <col style="width:400px;"/>
        </colgroup>
        <thead>
            <tr>
                <th>구분</th>
                <th>call</th>
                <th>apply</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>구문</td>
                <td>
                    fun.call([thisObj[, arg[, arg2[, ...]]]]) <br>
                    fun      : 가져다쓸 메소드 <br>
                    thisObj  : 현재 객체로 사용될 객체. 선택 사항입니다 <br>
                    arg, arg2 : 함수에 전달될 인수 집합 <br>
                </td>
                <td>
                    fun.apply([thisObj[,argArray]])<br>
                    fun      : 가져다쓸 메소드 <br>
                    thisObj  : 현재 객체로 사용될 객체. 선택 사항입니다 <br>
                    argArray : 함수에 전달될 인수 집합 <br>
                </td>
            </tr>
            <tr>
                <td>공통점</td>
                <td colspan="2">call과 apply의 공통점은 함수를 호출하는 메서드</td>     
            </tr>
            <tr>
                <td>차이점</td>
                <td colspan="2">
                    <p>
                    call과 apply의 차이점
                    1. 매개변수 전달 방식이 다르다.
                        call 메소드는 매개변수를 개별적으로 전달하는 방식이지만, 
                        apply 메소드는 매개변수를 배열에 담아서 한번에 전달하는 방식이다.
                    2. this의 사용 방법이 다르다.
                        call과 apply의 핵심은 this에 있습니다.
                        apply의 핵심은 this에 있습니다.
                        call 함수를 사용하게 되면, this에 해당 값들을 변경 할 수 있게 됩니다.
                    </p>
                </td>               
            </tr>

        </tbody>
    </table>

</body>
</html>
